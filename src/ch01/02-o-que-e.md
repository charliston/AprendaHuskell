# Então, o que é Haskell?

![](./assets/fx.png)

Haskell é uma **linguagem de programação puramente funcional**. Em linguagens imperativas, você realiza tarefas dando ao computador uma sequência de comandos e, em seguida, ele os executa. Durante a execução, pode haver mudanças de estado. Por exemplo, você define a variável `a` como 5 e, em seguida, realiza algumas operações e a define como algo diferente. Existem estruturas de controle de fluxo para realizar uma ação várias vezes. Na programação funcional pura, você não diz ao computador o que fazer, mas sim o que as coisas são. O fatorial de um número é o produto de todos os números de 1 até esse número, a soma de uma lista de números é o primeiro número mais a soma de todos os outros números, e assim por diante. Você expressa isso na forma de funções. Além disso, você não pode definir uma variável como algo e depois alterá-la posteriormente. Se você diz que a é 5, não pode dizer que é outra coisa depois, pois acabou de dizer que era 5. O que você é, algum tipo de mentiroso? Portanto, em linguagens puramente funcionais, uma função não tem efeitos colaterais. A única coisa que uma função pode fazer é calcular algo e retorná-lo como resultado. A princípio, isso parece limitante, mas na verdade tem algumas consequências muito boas: se uma função é chamada duas vezes com os mesmos parâmetros, ela está garantida a retornar o mesmo resultado. Isso é chamado de transparência referencial e não apenas permite que o compilador raciocine sobre o comportamento do programa, mas também permite que você deduza (e até prove) facilmente que uma função está correta e, em seguida, construa funções mais complexas, unindo funções simples.

![](./assets/lazy.png)

Haskell é **preguiçoso**. Isso significa que, a menos que seja especificamente informado o contrário, Haskell não executará funções e calculará coisas até que seja realmente forçado a mostrar um resultado. Isso se alinha bem com a transparência referencial e permite que você pense em programas como uma série de **transformações em dados**. Também permite coisas legais, como estruturas de dados infinitas. Digamos que você tenha uma lista imutável de números `xs = [1,2,3,4,5,6,7,8]` e uma função `doubleMe` que multiplica cada elemento por 2 e depois retorna uma nova lista. Se quiséssemos multiplicar nossa lista por 8 em uma linguagem imperativa e fizéssemos `doubleMe(doubleMe(doubleMe(xs)))`, provavelmente passaria pela lista uma vez, faria uma cópia e então a retornaria. Em uma linguagem preguiçosa, chamar `doubleMe` em uma lista sem forçá-la a mostrar o resultado resulta no programa meio que dizendo "Sim, sim, eu farei isso depois!". Mas quando você quer ver o resultado, o primeiro `doubleMe` diz ao segundo que quer o resultado, agora! O segundo diz isso ao terceiro e o terceiro relutantemente devolve um 1 dobrado, que é um 2. O segundo recebe isso e devolve 4 ao primeiro. O primeiro vê isso e lhe diz que o primeiro elemento é 8. Assim, ele passa pela lista apenas uma vez e somente quando você realmente precisa. Dessa forma, quando você quer algo de uma linguagem preguiçosa, pode simplesmente pegar alguns dados iniciais e transformá-los eficientemente para que se assemelhem ao que você deseja no final.

![](./assets/boat.png)

Haskell é uma linguagem de programação **estaticamente tipada**. Quando você compila seu programa, o compilador sabe qual trecho de código é um número, qual é uma string e assim por diante. Isso significa que muitos erros possíveis são identificados em tempo de compilação. Se você tentar somar um número e uma string, o compilador reclamará. Haskell usa um sistema de tipos muito bom que possui **inferência de tipos**. Isso significa que você não precisa rotular explicitamente cada trecho de código com um tipo, porque o sistema de tipos pode descobrir muitas coisas sobre ele de forma inteligente. Se você disser `a = 5 + 4`, não precisa dizer a Haskell que `a` é um número, ele pode descobrir sozinho. A inferência de tipos também permite que seu código seja mais geral. Se uma função que você cria recebe dois parâmetros e os adiciona, e você não especifica explicitamente o tipo deles, a função funcionará com quaisquer dois parâmetros que se comportem como números.

Haskell é **elegante e conciso**. Por usar muitos conceitos de alto nível, os programas em Haskell geralmente são mais curtos do que seus equivalentes imperativos. E programas mais curtos são mais fáceis de manter do que os mais longos e têm menos bugs.

Haskell foi criado por **pessoas muito inteligentes** (com doutorado). O trabalho em Haskell começou em 1987, quando um comitê de pesquisadores se reuniu para projetar uma linguagem de programação excelente. Em 2003, o Relatório Haskell foi publicado, definindo uma versão estável da linguagem.
